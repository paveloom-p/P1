program main ! Интерполяция сплайнами
use subprograms ! Модуль с процедурами
implicit none

real(8), allocatable, dimension(:) :: x, y  ! Массивы аргументов и значений функции
real(8), allocatable, dimension(:) :: a_c, b_c, c_c, d_c ! Векторы коэффициентов

real(8) a, b ! Границы промежутка
integer n    ! Число промежутков деления
real(8) z    ! Аргумент, при котором будем искать значение аппроксимирующей функции

integer x_y_show  ! Ответ на вопрос о выводе таблицы узлов и значений в них
integer coef_show ! Ответ на вопрос о выволе таблицы с коэффициентами для сплайнов  

real(8) res ! Результат                         

integer ier, i ! Вспомогательные переменные
real(8) t1, t2 ! Переменные времени


! Считывание аргумента, в котором будем искать значение аппроксимирующей функции
read(*,'()'); read(*,*) z; read(*,'(/)')

! Считывание границ промежутка
read(*,*) a, b; read(*,'(/)')

! Считывание числа промежутков деления
read(*,*) n; read(*,'(/)')

! Считывание ответа на вопрос о выводе таблицы узлов и значений в них
read(*,*) x_y_show; read(*,'(/)')

! Считывание ответа на вопрос о выводе таблицы с коэффициентами для сплайнов
read(*,*) coef_show; read(*,'(/)')

! Выделение памяти под массивы
allocate (x(0:n), stat=ier); if (ier .ne. 0) stop 'Не могу выделить память для массива x'
allocate (y(0:n), stat=ier); if (ier .ne. 0) stop 'Не могу выделить память для массива y'

allocate (a_c(1:n), stat=ier); if (ier .ne. 0) stop 'Не могу выделить память для массива a_c'
allocate (b_c(1:n), stat=ier); if (ier .ne. 0) stop 'Не могу выделить память для массива b_c'
allocate (c_c(1:n+1), stat=ier); if (ier .ne. 0) stop 'Не могу выделить память для массива c_c'
allocate (d_c(1:n), stat=ier); if (ier .ne. 0) stop 'Не могу выделить память для массива d_c'

! Считывание исходных данных таблично заданной функции
do i = 0, n
        read(*,*) x(i), y(i)
enddo 

! Вывод известной информации:
write(*,'(/,4x,a,/)') 'Интерполяция сплайнами'

write(*,'(4x,a,/,4x,a,e16.7,/,4x,a,e16.7)') 'Границы промежутка:', 'a    = ', a, 'b    = ', b

if (x_y_show .ne. 0) then
        write(*,'(/,4x,a,//,7x,a,12x,a,18x,a)') 'Узлы и значения в них:', '№', 'X', 'Y'
        write(*,'(t3,i6,2x,e17.7,2x,e17.7)') (i,x(i),y(i),i=0,n)
endif

! Вызов функции, вывод результата
call cpu_time(t1)

call splines(x,y,z,n,a_c,b_c,c_c,d_c,res)

call cpu_time(t2)

if (coef_show .ne. 0) then
        write(*,'(/,4x,a,//,7x,a,12x,a,18x,a,18x,a,18x,a)') 'Коэффициенты сплайнов:', &
        &'i', 'a', 'b', 'c', 'd'
        write(*,'(t3,i6,2x,e17.7,2x,e17.7,2x,e17.7,2x,e17.7)') (i,a_c(i),b_c(i),c_c(i),d_c(i),i=1,n)
endif

write(*,'(/,4x,a,/,4x,a,1x,e16.7)') 'Ищем значение аппроксимирующей &
&функции в точке', 'x    =', z

write(*,'(/,4x,a)') 'Результат:'
write(*,'(4x,a,e16.7,/)') 'y    = ', res

write(*,'(4x,a,e15.7,/)') 'Время выполнения:', t2-t1

deallocate(x,y,a_c,b_c,c_c,d_c)

end program
